# 几种常见升级方式
---

## 一. bootloader直接升级
---

- 手动重启设备(重新上电或复位)
- 启动后设备首先允许bootloader,并等待(比如10S)指令或升级文件
- 在等待时机内,通过串口等发送升级指令或升级文件
- 接收升级文件,并烧写到Flash中,并置升级成功标志
- 跳转到Flash地址执行
- 如设备未在指定时间内接收到指令或数据,直接跳转到Flash地址执行
- 如升级失败,只能人工重启,继续升级

 
---
-  ROM分区

- | bootloader | 应用程序 | 用户参数存储 |

- **适合Flash比较小的MCU**

---

## 二. 外部Flash缓存
---

### 应用程序功能

- 通过任何能够获取数据的途径(串口,以太网,无线等),将接收到升级数据缓存到外部Flash中
- 置需要升级标志,并写入到参数存储区(供bootloader使用)
- 自动复位重启设备

### bootloader功能

- 设备启动,先进入bootloader区,并读取是否需要升级标志
- 如无需升级,直接跳转到程序运行区执行应用程序
- 如需要升级,将外部Flash中的升级文件,烧写到ROM区,并置升级完成标志
- 跳转到程序运行区执行应用程序
- 同时,该bootloader可以具备直接升级的功能

 
---
-  ROM分区
- | bootloader | 应用程序 | 用户参数存储 | 升级标志 |
- | 外部Flash 文件缓存区 | ... |

* 或
- | bootloader | 应用程序 | 文件缓存 | 用户参数存储 | 升级标志 |

- **适合有较大Flash或外置Flash的MCU**

---

### 缺点
- 升级文件使用同一地址,缺点是升级失败只能人工处理



## 三. 双应用程序区
---

### 应用程序功能

- 通过任何能够获取数据的途径(串口,以太网,无线等),将接收到升级数据存到另一个分区
- 置升级运行区域标志

### bootloader功能

- 设备启动,先进入bootloader区,并读取程序运行区域标志
- 跳转到程序运行区执行应用程序
- 同时,该bootloader可以具备直接升级的功能

---
- ROM分区

- | bootloader | 应用程序1 | 应用程序2 | 用户参数存储 | 升级标志 |

- **适用于片内Flash非常大的MCU,通过程序设计,可以实现最好的功能** 

---

### 缺点
- 制作升级文件需要注意地址, 升级程序需要做两份, 用于适配跨版本升级

# 四. 带恢复出厂设置

---
-  ROM分区
- | bootloader | 应用程序 | 升级文件缓存 | 恢复出厂程序 | 用户参数存储 | 升级标志 |

* 或
- 内部Flash | bootloader | 应用程序 | 用户参数存储 | 升级标志 |
- 外部Flash | 升级文件缓存区 | 恢复出厂缓存 | 其他... |

- **适合有较大Flash或外置Flash的MCU**

---


# 五. 升级注意事项

* 编译程序设置(程序运行地址等)
* 第一次烧写文件的制作(不能让生产部门太麻烦)
* bin及HEX文件的校验(尤其Bin文件的安全性)
* 升级失败的处理
* 升级协议中,最后保护设备类型,软件版本号等基本信息,方便校验

# 五. 升级标志

> 
    struct BootFlagStruct
	{
		//0: 无需升级或生产完成
		//1: 固件传输完成
		//2: 更新固件
		//3: 固件升级失败, 返回原程序执行
    	int upgradestep; // 升级标志
		int upAddress;// 新固件地址
		int clearPara;// 是否清除原参数区
    }




| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |

